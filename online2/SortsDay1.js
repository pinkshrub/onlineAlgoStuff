// 0: Hi!!!!!! Happpppy Tuesday! 5 days until Christmas I think!!!!
// 1: Context
//  0. Show'n'Tell
//    - dedupe lvl. 4
//    - maxSubArraySums 2.0
// 	a. We are doing sorts
// 	b. Today is intro to measures
// 	c. were we planning on fun friday?
// 2: Sorting!
// 	a. Why? -duh..
// 	b. So, how?
// 		a. Quantify performance in space and time
// 		b. enter ......
// 	C. BIG O NOTATION
// 		a. A theoretical metric for space and time complexity, always assumes worst-case performance isolates growth of input size which is environment independant
// 		b.
// 		O(1): 		constant: operation is independant of input size, e.g. sLL addFront. Always takes the same amount of time
// 		O(n):       linear: operation grows linearly with input size, e.g. sum array or contains
// 		O(log n):   logarithmic: problems that break something into smaller and smaller pieces, BST search.
// 					  Larger input increases runtime disproportionately in a good way. eg size 10 = 1 sec, size 100 = 2 sec, size 1000 = 3 sec
// 		O(n log n): breaks things apart similar to log n, then stitches them back together
// 		O(n2):      quadratic: usually nested for loops, bubSort
// 		O(n3):      cubic: rare
// 		O(2n):      exponential: Growth doubles with each input. rFib
// 3: Today's Mission
// 	a. Bubble Sort
// 	b. Selection Sort
// 	c. Insertion Sort
// 	d. Partition and merge sorted arrays

// stable, in place, non-nested loops
function dedupe4(array){
  #bufferlief!
}





function bubSort(array){
	// bububububble

}

function selSort(list){
	// put minimum to leftest
}

function inSort(list){
	// everytyhing to left is sorted
}

function partition(list){
	// partition on list[0]
}

function mergeArrays(list1, list2){
	// merge sorted lists
}
